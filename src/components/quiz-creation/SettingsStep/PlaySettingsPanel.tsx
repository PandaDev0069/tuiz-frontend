'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Card, CardContent, CardHeader, CardTitle, Switch, Input, Label } from '@/components/ui';
import { Settings, Users, Clock, Trophy, Eye, EyeOff, RefreshCw } from 'lucide-react';
import { QuizPlaySettings } from '@/types/quiz';
import { useGenerateCode, useCodeValidation } from '@/hooks/useCodeManagement';

interface PlaySettingsPanelProps {
  playSettings: Partial<QuizPlaySettings>;
  onPlaySettingsChange: (settings: Partial<QuizPlaySettings>) => void;
  isMobile: boolean;
  errors: Record<string, string>;
  quizId?: string;
}

// Extract Quiz Code Section Component
const QuizCodeSection: React.FC<{
  playSettings: Partial<QuizPlaySettings>;
  onPlaySettingsChange: (settings: Partial<QuizPlaySettings>) => void;
  isMobile: boolean;
  errors: Record<string, string>;
  quizId?: string;
}> = ({ playSettings, onPlaySettingsChange, isMobile, errors, quizId }) => {
  const [isGeneratingCode, setIsGeneratingCode] = useState(false);
  const [codeInput, setCodeInput] = useState(playSettings.code?.toString() || '');
  const [hasUserEdited, setHasUserEdited] = useState(false);
  const [validationMessage, setValidationMessage] = useState('');
  const [isValidating, setIsValidating] = useState(false);
  const [validationTimeout, setValidationTimeout] = useState<NodeJS.Timeout | null>(null);
  const hasAutoGenerated = useRef(false);

  // Import hooks
  const generateCodeMutation = useGenerateCode();
  const { validateCode, isChecking } = useCodeValidation();

  const handleGenerateCode = useCallback(async () => {
    setIsGeneratingCode(true);

    try {
      if (!quizId) {
        // Fallback to client-side generation if no quizId
        const randomCode = Math.floor(100000 + Math.random() * 900000);
        setCodeInput(randomCode.toString());
        onPlaySettingsChange({ code: randomCode });
        setValidationMessage('ローカルでコードを生成しました');
        return;
      }

      const result = await generateCodeMutation.mutateAsync(quizId);
      setCodeInput(result.code.toString());
      setHasUserEdited(false);
      onPlaySettingsChange({ code: result.code });
      setValidationMessage('新しいコードが生成されました');
    } catch {
      // Fallback to client-side generation on error
      const randomCode = Math.floor(100000 + Math.random() * 900000);
      setCodeInput(randomCode.toString());
      setHasUserEdited(false);
      onPlaySettingsChange({ code: randomCode });
      setValidationMessage('サーバーエラーのため、ローカルでコードを生成しました');
    } finally {
      setIsGeneratingCode(false);
    }
  }, [quizId, generateCodeMutation, onPlaySettingsChange]);

  // Auto-generate code when component mounts if no code is set or code is 0
  // Only auto-generate if user hasn't manually edited the code
  useEffect(() => {
    if (
      (!playSettings.code || playSettings.code === 0) &&
      !hasUserEdited &&
      quizId &&
      !hasAutoGenerated.current
    ) {
      hasAutoGenerated.current = true;
      handleGenerateCode();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [quizId, playSettings.code, hasUserEdited]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (validationTimeout) {
        clearTimeout(validationTimeout);
      }
    };
  }, [validationTimeout]);

  const handleCodeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    // Only allow 6-digit numbers
    if (value.length <= 6 && /^\d*$/.test(value)) {
      setCodeInput(value);
      setHasUserEdited(true);
      setValidationMessage('');

      const codeNumber = parseInt(value) || 0;
      onPlaySettingsChange({ code: codeNumber });

      // Clear existing timeout
      if (validationTimeout) {
        clearTimeout(validationTimeout);
      }

      // Validate code if it's complete (6 digits) with debouncing
      if (value.length === 6 && codeNumber >= 100000) {
        const timeout = setTimeout(() => {
          validateCodeAsync(codeNumber);
        }, 500); // 500ms debounce
        setValidationTimeout(timeout);
      }
    }
  };

  const validateCodeAsync = async (code: number) => {
    setIsValidating(true);
    try {
      const result = await validateCode(code);
      setValidationMessage(result.message);
    } catch {
      setValidationMessage('コードの確認中にエラーが発生しました');
    } finally {
      setIsValidating(false);
    }
  };

  const handleCodeBlur = () => {
    // Format with leading zeros when user finishes typing
    if (codeInput && codeInput.length < 6) {
      const formattedCode = codeInput.padStart(6, '0');
      setCodeInput(formattedCode);
      const codeNumber = parseInt(formattedCode);
      onPlaySettingsChange({ code: codeNumber });

      // Validate the formatted code
      if (codeNumber >= 100000) {
        validateCodeAsync(codeNumber);
      }
    }
  };

  return (
    <div className="bg-white rounded-lg p-4 border border-gray-200 shadow-sm">
      <div className="flex items-center justify-between mb-3">
        <Label variant="primary" size={isMobile ? 'md' : 'lg'} className="font-semibold">
          クイズコード
        </Label>
        <button
          type="button"
          onClick={handleGenerateCode}
          disabled={isGeneratingCode}
          className="flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-700 rounded-lg text-sm hover:bg-blue-200 transition-colors disabled:opacity-50"
        >
          <RefreshCw className={`w-3 h-3 ${isGeneratingCode ? 'animate-spin' : ''}`} />
          {isGeneratingCode ? '生成中...' : 'ランダム生成'}
        </button>
      </div>
      <div className="relative">
        <Input
          type="text"
          value={codeInput}
          onChange={handleCodeChange}
          onBlur={handleCodeBlur}
          placeholder="123456"
          maxLength={6}
          className="text-center text-lg font-mono tracking-wider"
          disabled={isGeneratingCode}
        />
        {(isValidating || isChecking) && (
          <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
            <RefreshCw className="w-4 h-4 animate-spin text-blue-500" />
          </div>
        )}
      </div>

      {/* Error messages */}
      {errors.code && <div className="text-red-600 text-sm mt-1">{errors.code}</div>}

      {/* Validation messages */}
      {validationMessage && (
        <div
          className={`text-sm mt-1 ${
            validationMessage.includes('使用可能') || validationMessage.includes('生成されました')
              ? 'text-green-600'
              : validationMessage.includes('使用されています') ||
                  validationMessage.includes('エラー')
                ? 'text-red-600'
                : 'text-gray-600'
          }`}
        >
          {validationMessage}
        </div>
      )}

      <p className="text-xs text-gray-500 mt-1">
        プレイヤーがクイズに参加する際に使用する6桁のコード
      </p>
    </div>
  );
};

// Extract Display Settings Section Component
const DisplaySettingsSection: React.FC<{
  playSettings: Partial<QuizPlaySettings>;
  onPlaySettingsChange: (settings: Partial<QuizPlaySettings>) => void;
  isMobile: boolean;
}> = ({ playSettings, onPlaySettingsChange, isMobile }) => {
  const handleSwitchChange = (field: keyof QuizPlaySettings, value: boolean) => {
    onPlaySettingsChange({ [field]: value });
  };

  return (
    <div className="bg-white rounded-lg p-4 border border-gray-200 shadow-sm">
      <h3 className={`${isMobile ? 'text-sm' : 'text-base'} font-semibold text-gray-900 mb-4`}>
        表示設定
      </h3>
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Eye className="w-4 h-4 text-gray-600" />
            <span className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-700`}>
              問題のみ表示
            </span>
          </div>
          <Switch
            checked={playSettings.show_question_only ?? true}
            onCheckedChange={(checked) => handleSwitchChange('show_question_only', checked)}
          />
        </div>
        <p className="text-xs text-gray-500 ml-6">回答前に問題のみを表示し、選択肢は回答時に表示</p>

        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <EyeOff className="w-4 h-4 text-gray-600" />
            <span className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-700`}>
              正解を表示
            </span>
          </div>
          <Switch
            checked={playSettings.show_correct_answer ?? false}
            onCheckedChange={(checked) => handleSwitchChange('show_correct_answer', checked)}
          />
        </div>
        <p className="text-xs text-gray-500 ml-6">回答後に正解を表示するかどうか</p>

        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Settings className="w-4 h-4 text-gray-600" />
            <span className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-700`}>
              解説を表示
            </span>
          </div>
          <Switch
            checked={playSettings.show_explanation ?? true}
            onCheckedChange={(checked) => handleSwitchChange('show_explanation', checked)}
          />
        </div>
        <p className="text-xs text-gray-500 ml-6">回答後に解説を表示するかどうか</p>
      </div>
    </div>
  );
};

// Extract Bonus Settings Section Component
const BonusSettingsSection: React.FC<{
  playSettings: Partial<QuizPlaySettings>;
  onPlaySettingsChange: (settings: Partial<QuizPlaySettings>) => void;
  isMobile: boolean;
}> = ({ playSettings, onPlaySettingsChange, isMobile }) => {
  const handleSwitchChange = (field: keyof QuizPlaySettings, value: boolean) => {
    onPlaySettingsChange({ [field]: value });
  };

  return (
    <div className="bg-white rounded-lg p-4 border border-gray-200 shadow-sm">
      <h3 className={`${isMobile ? 'text-sm' : 'text-base'} font-semibold text-gray-900 mb-4`}>
        ボーナス設定
      </h3>
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Clock className="w-4 h-4 text-gray-600" />
            <span className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-700`}>
              時間ボーナス
            </span>
          </div>
          <Switch
            checked={playSettings.time_bonus ?? true}
            onCheckedChange={(checked) => handleSwitchChange('time_bonus', checked)}
          />
        </div>
        <p className="text-xs text-gray-500 ml-6">早く回答したプレイヤーにボーナスポイントを付与</p>

        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Trophy className="w-4 h-4 text-gray-600" />
            <span className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-700`}>
              連続正解ボーナス
            </span>
          </div>
          <Switch
            checked={playSettings.streak_bonus ?? true}
            onCheckedChange={(checked) => handleSwitchChange('streak_bonus', checked)}
          />
        </div>
        <p className="text-xs text-gray-500 ml-6">連続で正解した場合にボーナスポイントを付与</p>
      </div>
    </div>
  );
};

// Extract Player Limit Section Component
const PlayerLimitSection: React.FC<{
  playSettings: Partial<QuizPlaySettings>;
  onPlaySettingsChange: (settings: Partial<QuizPlaySettings>) => void;
  isMobile: boolean;
  errors: Record<string, string>;
}> = ({ playSettings, onPlaySettingsChange, isMobile, errors }) => {
  const handleMaxPlayersChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (!isNaN(value) && value >= 1 && value <= 400) {
      onPlaySettingsChange({ max_players: value });
    }
  };

  return (
    <div className="bg-white rounded-lg p-4 border border-gray-200 shadow-sm">
      <div className="flex items-center gap-2 mb-3">
        <Users className="w-4 h-4 text-gray-600" />
        <Label variant="primary" size={isMobile ? 'md' : 'lg'} className="font-semibold">
          最大プレイヤー数
        </Label>
      </div>
      <Input
        type="number"
        value={playSettings.max_players || 400}
        onChange={handleMaxPlayersChange}
        min={1}
        max={400}
        className="w-24"
      />
      {errors.max_players && <div className="text-red-600 text-sm mt-1">{errors.max_players}</div>}
      <p className="text-xs text-gray-500 mt-1">同時に参加できる最大プレイヤー数（1-400人）</p>
    </div>
  );
};

export const PlaySettingsPanel: React.FC<PlaySettingsPanelProps> = ({
  playSettings,
  onPlaySettingsChange,
  isMobile,
  errors,
  quizId,
}) => {
  return (
    <Card className="bg-gradient-to-br from-lime-200 to-green-300 border-lime-400 shadow-sm">
      <CardHeader className={`${isMobile ? 'pb-4 px-4' : 'pb-6 px-6'}`}>
        <CardTitle className={`flex items-center gap-2 ${isMobile ? 'text-base' : 'text-lg'}`}>
          <div className="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center text-sm font-bold">
            <Settings className="w-4 h-4" />
          </div>
          プレイ設定
        </CardTitle>
        <p className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-600`}>
          クイズのプレイ方法と表示設定を調整できます
        </p>
      </CardHeader>

      <CardContent className={`${isMobile ? 'px-4' : 'px-6'}`}>
        <div className="space-y-6">
          <QuizCodeSection
            playSettings={playSettings}
            onPlaySettingsChange={onPlaySettingsChange}
            isMobile={isMobile}
            errors={errors}
            quizId={quizId}
          />

          <DisplaySettingsSection
            playSettings={playSettings}
            onPlaySettingsChange={onPlaySettingsChange}
            isMobile={isMobile}
          />

          <BonusSettingsSection
            playSettings={playSettings}
            onPlaySettingsChange={onPlaySettingsChange}
            isMobile={isMobile}
          />

          <PlayerLimitSection
            playSettings={playSettings}
            onPlaySettingsChange={onPlaySettingsChange}
            isMobile={isMobile}
            errors={errors}
          />
        </div>
      </CardContent>
    </Card>
  );
};
